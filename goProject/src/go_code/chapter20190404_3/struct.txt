golang的语言的面向对象编程说明：
    1 go也支持面向对象编程OOP，但是和传统的面向对象编程有区别，并不是纯粹
    的面向对象语言，所说义我们说go支持面向对象编程特性是比较准确的。

    2 go没有类class，go语言的结构体struct和其他的编程语言的类class有同等
    的地位，你也可以理解go是基于struct来实现oop特性的。

    3 go面向对象编程非常简洁，去掉了传统OOP语言的继承，方法重载、构造函数和
    析构函数、隐藏的this指针等等。

    4 go仍然有面向对象编程的继承、封装和多态的特性，只是实现的方式和其他OOP语言不一样，
    比如继承：go没有extends关键字，继承是通过匿名字段来实现的。

    5 go的面向对象很优雅，oop本身就是语言类型系统（type system）的一部分，通过接口
    interface关联，耦合性低，也非常灵活。后面会充分体会到，也就是说面向接口编程是非常
    重要的特性。



创建结构体变量和访问结构体字段方式：
    1 直接声明 var person Person
    2 {}
     var person Person = Person{}

    3 var person *Person= new{Person}  
    //这种方法new出来的是一个指向Person空间的指针
    person是指针，标准的赋值方式：(*person).Name = "marry",但是略显啰嗦，
    可以简化如下：
        person.Name="marry"
    这种方式可以使用的原因是，Go的设计者为了程序员使用方便，在底层会对
        person.Name="marry"
    进行处理，会给person加上取值运算：
        (*person).Name = "marry"

    4 var person *Person = &Person{}
    person是一个指针，因此标准的访问其字段的方法是：
        (*persoon).Name = "marry"
    go的设计者为了程序员使用方便，也可以直接写成person.Name="marry",原因同3一样的


细节：
 1 结构体的字段在内存中是连续的
 2 结构体是用户单独定义的类型，和其他类型进行转换的时候需要有完全相同的字段（名字、个数和类型）
 3 结构体进行type重新定义（相当于取别名），go认为是新的数据类型，但是相互可以强转
    比如：type integer int，给int取了别名integer，但是int和integer类型的变量不能直接赋值
但是相互可以强转
 4 struct每个字段上，可以写上一个tag，该tag可以通过反射机制获取，常见的使用场景就是序列化
 和反序列化。



方法基本介绍：
1 go中的方法是作用在指定的数据类型上的（即：和指定的数据类型绑定的），
因此自定义类型都可以有方法，而不仅仅是struc
    方法的声明和调用：
    type A struct{
        Num int
    }

    func (a A) test(){
        fmt.Println(a.Num)
    }
    语法说明：
    （1）func(a A) test(){}表示A结构体有一个方法，方法名为test
    (2) (a A)体现test方法是和A类型绑定的


方法的调用和传参机制原理：
    方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，会将调用方法的变量，当做实参
也传给方法。


方法的声明和调用：
func (receiver type) methodName (参数列表) (返回值列表){
    方法体
    return 返回值
}
（1） 参数列表：表示方法输入
（2）receiver type:表示这个方法和type这个类型绑定，或者说该方法作用于type类型
（3）receiver type:type可以是结构体，也可以是其他的自定义类型
（4）receiver：就是type类型的一个变量实例，比如Person接头体的一个变量（实例）
（5）返回值列表：表示返回值，可以多个
（6）方法主体：表示为了实现一个功能的代码块
 (7) return语句不是必须的


 方法注意事项和细节讨论：
 1 结构体类型时值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式
 2 如果程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理
 3 Go中的方法作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型，都可以有方法
 ，而不仅仅是struct，比如int，flocat32等都可以有方法。
 4 方法的访问范围控制的规则和函数一样，方法名首字母小写只能在本包访问，方法首字母大写，可以在本包和qitabao访问
 5 如果一个类型实现了String()这个方法，那么fmt.Println默认为调用这个变量的String()进行输出
 

方法和函数的区别：
1 调用方式不一样
    函数：函数名（实参列表）
    方法：变量.方法名(实参列表)

2 对于普通函数，接受者为值类型时，不能讲指针类型的数据直接传递，反之亦然

3 对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来也同样可以。

总结：不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定，
如果是和值类型绑定比如(p Pserson)则是值拷贝，如果是(p *Person)则是地址拷贝。












